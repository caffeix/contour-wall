<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ContourWall Games Poster</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --paper: #fff8ea;
      --ink: #1f1a15;
      --panel: #fffef8;
      --line: #d6c8ad;
      --shadow: rgba(31, 26, 21, 0.2);
      --orange: #ff5a2a;
      --teal: #00a4b2;
      --leaf: #1ba66b;
      --sun: #ffbe34;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 14% 12%, rgba(255, 190, 52, 0.23), transparent 42%),
        radial-gradient(circle at 86% 11%, rgba(0, 164, 178, 0.2), transparent 44%),
        radial-gradient(circle at 80% 85%, rgba(255, 90, 42, 0.17), transparent 48%),
        var(--paper);
      min-height: 100vh;
      line-height: 1.3;
    }

    .poster {
      width: min(1120px, 94vw);
      margin: 1.9rem auto;
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.9), rgba(255, 248, 234, 0.95));
      border: 3px solid var(--ink);
      box-shadow: 10px 10px 0 var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .poster::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          -20deg,
          transparent 0,
          transparent 24px,
          rgba(214, 200, 173, 0.28) 24px,
          rgba(214, 200, 173, 0.28) 27px
        );
      pointer-events: none;
    }

    header {
      position: relative;
      z-index: 1;
      padding: 2rem 2rem 1rem;
      border-bottom: 3px solid var(--ink);
      display: grid;
      gap: 0.45rem;
    }

    .eyebrow {
      margin: 0;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--teal);
    }

    h1 {
      margin: 0;
      font-family: "Bebas Neue", Impact, sans-serif;
      letter-spacing: 0.06em;
      font-size: clamp(3rem, 9vw, 6.8rem);
      line-height: 0.95;
      text-transform: uppercase;
    }

    .subtitle {
      margin: 0;
      max-width: 48ch;
      font-size: clamp(0.98rem, 1.9vw, 1.2rem);
      font-weight: 600;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.3rem;
    }

    .chip {
      border: 2px solid var(--ink);
      background: var(--panel);
      padding: 0.2rem 0.56rem;
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    main {
      position: relative;
      z-index: 1;
      padding: 1.2rem 1rem 1.45rem;
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 1rem;
    }

    .card {
      grid-column: span 6;
      border: 2px solid var(--ink);
      background: var(--panel);
      box-shadow: 6px 6px 0 rgba(31, 26, 21, 0.12);
      padding: 1rem 1rem 0.9rem;
      display: grid;
      gap: 0.58rem;
      animation: rise 620ms ease both;
    }

    .card:nth-child(2) {
      animation-delay: 100ms;
    }

    .card:nth-child(3) {
      animation-delay: 200ms;
    }

    .card:nth-child(4) {
      animation-delay: 300ms;
    }

    @keyframes rise {
      from {
        transform: translateY(12px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .tag {
      margin: 0;
      width: fit-content;
      border: 2px solid var(--ink);
      background: #fff;
      font-size: 0.73rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 0.15rem 0.46rem;
    }

    .tag-runner {
      background: rgba(255, 90, 42, 0.16);
    }

    .tag-breaker {
      background: rgba(0, 164, 178, 0.16);
    }

    .tag-lane {
      background: rgba(27, 166, 107, 0.16);
    }

    .tag-hole {
      background: rgba(122, 128, 255, 0.17);
    }

    .card h2 {
      margin: 0;
      font-family: "Bebas Neue", Impact, sans-serif;
      font-size: 2rem;
      letter-spacing: 0.04em;
      line-height: 0.95;
    }

    .scene {
      border: 2px solid var(--ink);
      border-radius: 6px;
      overflow: hidden;
      background: #101626;
      aspect-ratio: 18 / 11;
    }

    .sim-canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .hook {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
    }

    .mini-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.38rem;
    }

    .mini-chips span {
      border: 1.5px solid var(--ink);
      background: #fff;
      padding: 0.12rem 0.42rem;
      font-size: 0.74rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .cta {
      grid-column: 1 / -1;
      border: 3px solid var(--ink);
      background: linear-gradient(120deg, rgba(255, 190, 52, 0.34), rgba(255, 90, 42, 0.2));
      text-align: center;
      padding: 1rem 1rem 1.1rem;
      position: relative;
      overflow: hidden;
    }

    .cta h3 {
      margin: 0;
      font-family: "Bebas Neue", Impact, sans-serif;
      font-size: clamp(1.7rem, 4vw, 2.4rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .cta p {
      margin: 0.2rem 0 0;
      font-size: 0.96rem;
      font-weight: 600;
    }

    .cta::before {
      content: "";
      position: absolute;
      top: 0;
      left: -40%;
      width: 40%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.45), transparent);
      animation: shine 3s linear infinite;
    }

    @keyframes shine {
      from {
        left: -40%;
      }
      to {
        left: 120%;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation: none !important;
        transition: none !important;
      }
    }

    @media (max-width: 960px) {
      .card {
        grid-column: span 6;
      }
    }

    @media (max-width: 680px) {
      .poster {
        width: 96vw;
        margin: 1rem auto;
      }

      header {
        padding: 1.35rem 1rem 0.85rem;
      }

      main {
        padding: 0.82rem;
      }

      .card {
        grid-column: 1 / -1;
      }
    }
  </style>
</head>
<body>
  <article class="poster">
    <header>
      <p class="eyebrow">ContourWall Arcade</p>
      <h1>Play The Wall</h1>
      <p class="subtitle">These animated scenes mirror the actual game rules from the project code.</p>
      <div class="chips">
        <span class="chip">4 Modes</span>
        <span class="chip">Move</span>
        <span class="chip">React</span>
        <span class="chip">Survive</span>
      </div>
    </header>

    <main>
      <section class="card">
        <p class="tag tag-runner">Endless Runner</p>
        <h2>Subway Surfers</h2>
        <div class="scene">
          <canvas id="sim-runner" class="sim-canvas" width="360" height="220" aria-hidden="true"></canvas>
        </div>
        <p class="hook">Dodge blockers and collect safe-lane coins.</p>
        <div class="mini-chips">
          <span>24% double blockers</span>
          <span>coin +45</span>
          <span>hit -> invuln 18f</span>
        </div>
      </section>

      <section class="card">
        <p class="tag tag-breaker">Classic Arcade</p>
        <h2>Brick Breaker</h2>
        <div class="scene">
          <canvas id="sim-breaker" class="sim-canvas" width="360" height="220" aria-hidden="true"></canvas>
        </div>
        <p class="hook">Bounce control, brick clears, and level progression.</p>
        <div class="mini-chips">
          <span>+12 + 2x level / brick</span>
          <span>rows 4 to 7</span>
          <span>clear all -> level +1</span>
        </div>
      </section>

      <section class="card">
        <p class="tag tag-lane">Reaction Challenge</p>
        <h2>Lane Stay</h2>
        <div class="scene">
          <canvas id="sim-lane" class="sim-canvas" width="360" height="220" aria-hidden="true"></canvas>
        </div>
        <p class="hook">Timed lane target, particle bursts, and FASTER speed ramps.</p>
        <div class="mini-chips">
          <span>every 3 hits = 10% faster</span>
          <span>FASTER flash pause</span>
          <span>tick floor 0.5s</span>
        </div>
      </section>

      <section class="card">
        <p class="tag tag-hole">Gap Timing</p>
        <h2>Hole Runner</h2>
        <div class="scene">
          <canvas id="sim-hole" class="sim-canvas" width="360" height="220" aria-hidden="true"></canvas>
        </div>
        <p class="hook">Thread the moving line through the hole before impact.</p>
        <div class="mini-chips">
          <span>line 0.08s -> 0.02s</span>
          <span>+1 per pass</span>
          <span>miss = game over</span>
        </div>
      </section>

      <section class="cta">
        <h3>Pick Your Game. Own The Wall.</h3>
        <p>Exact mechanics, arcade energy.</p>
      </section>
    </main>
  </article>

  <script>
    (() => {
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const rgb = (r, g, b) => `rgb(${r}, ${g}, ${b})`;

      function makeGrid(canvas, cols, rows) {
        const ctx = canvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        const width = canvas.width;
        const height = canvas.height;
        const cellW = width / cols;
        const cellH = height / rows;

        function fillRect(row0, row1, col0, col1, color) {
          const r0 = clamp(Math.floor(row0), 0, rows);
          const r1 = clamp(Math.ceil(row1), 0, rows);
          const c0 = clamp(Math.floor(col0), 0, cols);
          const c1 = clamp(Math.ceil(col1), 0, cols);
          if (r1 <= r0 || c1 <= c0) return;
          ctx.fillStyle = color;
          ctx.fillRect(c0 * cellW, r0 * cellH, (c1 - c0) * cellW, (r1 - r0) * cellH);
        }

        function setPixel(row, col, color) {
          if (row < 0 || row >= rows || col < 0 || col >= cols) return;
          ctx.fillStyle = color;
          ctx.fillRect(col * cellW, row * cellH, cellW, cellH);
        }

        function overlay(color, alpha) {
          ctx.fillStyle = color;
          ctx.globalAlpha = alpha;
          ctx.fillRect(0, 0, width, height);
          ctx.globalAlpha = 1;
        }

        return {
          ctx,
          cols,
          rows,
          width,
          height,
          fillRect,
          setPixel,
          overlay,
        };
      }

      function createRunnerSim(canvas) {
        const cols = 36;
        const rows = 24;
        const g = makeGrid(canvas, cols, rows);
        const stepDt = 0.044;
        let accumulator = 0;

        const state = {
          rows,
          cols,
          baseRow: Math.max(5, rows - 4),
          laneCenters: [0, 0, 0],
          playerLane: 1,
          playerX: 0,
          invulnTimer: 0,
          crashFlash: 0,
          obstacles: [],
          coins: [],
          score: 0,
          collectedCoins: 0,
          distance: 0,
          lives: 3,
          frame: 0,
          baseSpeed: 0.66,
          maxSpeed: 1.46,
          speedRamp: 0.00185,
          spawnPadding: 0,
          speed: 0.66,
          spawnTimer: 15,
          gameOverPause: 0,
        };

        function computeLaneCenters() {
          return [
            Math.max(3, Math.floor(cols / 6)),
            Math.floor(cols / 2),
            Math.min(cols - 4, Math.floor((cols * 5) / 6)),
          ];
        }

        function resetRound() {
          state.baseRow = Math.max(5, rows - 4);
          state.laneCenters = computeLaneCenters();
          state.playerLane = 1;
          state.playerX = state.laneCenters[state.playerLane];
          state.invulnTimer = 0;
          state.crashFlash = 0;
          state.obstacles = [];
          state.coins = [];
          state.score = 0;
          state.collectedCoins = 0;
          state.distance = 0;
          state.lives = 3;
          state.frame = 0;
          state.speed = state.baseSpeed;
          state.spawnTimer = 15;
          state.gameOverPause = 0;
        }

        function spawnWave() {
          const lanes = [0, 1, 2].sort(() => Math.random() - 0.5);
          const blockLanes = Math.random() < 0.24 ? lanes.slice(0, 2) : [lanes[0]];
          for (const lane of blockLanes) {
            state.obstacles.push({ lane, y: -2.2 });
          }
          const safeLanes = [0, 1, 2].filter((lane) => !blockLanes.includes(lane));
          if (safeLanes.length > 0 && Math.random() < 0.78) {
            state.coins.push({ lane: pick(safeLanes), y: -3.5 });
          }

          const minGap = Math.max(10, Math.floor(24 - state.speed * 6) + state.spawnPadding);
          const maxGap = Math.max(minGap + 2, Math.floor(33 - state.speed * 6) + state.spawnPadding);
          state.spawnTimer = randInt(minGap, maxGap);
        }

        function autoChooseLane() {
          let bestLane = state.playerLane;
          let bestScore = -1e9;
          for (let lane = 0; lane < 3; lane += 1) {
            let danger = 0;
            let coinBonus = 0;
            for (const obstacle of state.obstacles) {
              if (obstacle.lane !== lane) continue;
              const dy = obstacle.y - state.baseRow;
              if (dy > -9 && dy < 3) {
                danger += 12 - Math.abs(dy);
              }
            }
            for (const coin of state.coins) {
              if (coin.lane !== lane) continue;
              const dy = Math.abs(coin.y - state.baseRow);
              if (dy < 14) {
                coinBonus += (14 - dy) * 0.5;
              }
            }
            const centerBias = lane === 1 ? 0.35 : 0;
            const laneScore = coinBonus + centerBias - danger;
            if (laneScore > bestScore) {
              bestScore = laneScore;
              bestLane = lane;
            }
          }
          if (bestLane < state.playerLane) state.playerLane -= 1;
          if (bestLane > state.playerLane) state.playerLane += 1;
        }

        function checkCollisions() {
          const playerRow = state.baseRow;
          if (state.invulnTimer <= 0) {
            const playerTop = playerRow - 2;
            const playerBottom = playerRow + 1;
            for (const obstacle of state.obstacles) {
              if (obstacle.lane !== state.playerLane) continue;
              if (!(playerTop - 1 <= obstacle.y && obstacle.y <= playerBottom + 1)) continue;
              state.lives -= 1;
              state.invulnTimer = 18;
              state.crashFlash = 10;
              state.obstacles = [];
              state.coins = [];
              state.playerLane = 1;
              state.playerX = state.laneCenters[state.playerLane];
              state.spawnTimer = 16;
              if (state.lives <= 0) {
                state.gameOverPause = 52;
              }
              return;
            }
          }

          const remainingCoins = [];
          for (const coin of state.coins) {
            if (coin.lane === state.playerLane && Math.abs(coin.y - playerRow) <= 1.6) {
              state.collectedCoins += 1;
              state.score += 45;
            } else {
              remainingCoins.push(coin);
            }
          }
          state.coins = remainingCoins;
        }

        function logicStep() {
          if (state.gameOverPause > 0) {
            state.gameOverPause -= 1;
            if (state.gameOverPause === 0) resetRound();
            return;
          }

          autoChooseLane();
          state.frame += 1;
          state.speed = Math.min(state.maxSpeed, state.baseSpeed + state.distance * state.speedRamp);
          state.distance += state.speed;
          state.score += Math.floor(1 + state.speed * 1.2);

          if (state.invulnTimer > 0) state.invulnTimer -= 1;
          if (state.crashFlash > 0) state.crashFlash -= 1;

          const targetX = state.laneCenters[state.playerLane];
          state.playerX += clamp(targetX - state.playerX, -2.9, 2.9);

          if (state.spawnTimer <= 0) {
            spawnWave();
          } else {
            state.spawnTimer -= 1;
          }

          for (const obstacle of state.obstacles) obstacle.y += state.speed;
          for (const coin of state.coins) coin.y += state.speed * 1.02;

          state.obstacles = state.obstacles.filter((o) => o.y < rows + 3);
          state.coins = state.coins.filter((c) => c.y < rows + 2);
          checkCollisions();
        }

        function drawRunner() {
          const row = state.baseRow;
          const x = Math.round(state.playerX);
          let outline = [6, 10, 18];
          let head = [255, 232, 124];
          let torso = [82, 246, 232];
          let accent = [128, 255, 244];
          let laneMarker = [255, 245, 148];

          if (state.invulnTimer > 0 && state.invulnTimer % 2 === 1) {
            const dim = 0.42;
            outline = outline.map((v) => Math.floor(v * dim));
            head = head.map((v) => Math.floor(v * dim));
            torso = torso.map((v) => Math.floor(v * dim));
            accent = accent.map((v) => Math.floor(v * dim));
            laneMarker = laneMarker.map((v) => Math.floor(v * dim));
          }

          g.fillRect(row + 2, row + 3, x - 2, x + 3, rgb(laneMarker[0], laneMarker[1], laneMarker[2]));
          const stepPhase = Math.floor(state.frame / 3) % 2;
          const legCols = stepPhase === 0 ? [-1, 1] : [-2, 0];
          const armOffsets = stepPhase === 0 ? [[-1, -2], [-1, 2]] : [[-2, -2], [-2, 2]];

          const sprite = [
            [row - 3, x, head],
            [row - 2, x - 1, head],
            [row - 2, x, head],
            [row - 2, x + 1, head],
            [row - 1, x - 1, torso],
            [row - 1, x, torso],
            [row - 1, x + 1, torso],
            [row, x - 1, torso],
            [row, x, torso],
            [row, x + 1, torso],
          ];

          for (const [dr, dc] of armOffsets) sprite.push([row + dr, x + dc, accent]);
          for (const dc of legCols) sprite.push([row + 1, x + dc, accent]);

          const occupied = new Set();
          for (const [r, c] of sprite) {
            if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
            occupied.add(`${r},${c}`);
          }

          for (const key of occupied) {
            const [r, c] = key.split(",").map(Number);
            for (let nr = r - 1; nr <= r + 1; nr += 1) {
              for (let nc = c - 1; nc <= c + 1; nc += 1) {
                if (occupied.has(`${nr},${nc}`)) continue;
                g.setPixel(nr, nc, rgb(outline[0], outline[1], outline[2]));
              }
            }
          }

          for (const [r, c, color] of sprite) {
            g.setPixel(r, c, rgb(color[0], color[1], color[2]));
          }
        }

        function drawHud() {
          for (let i = 0; i < state.lives; i += 1) {
            const start = i * 3;
            g.fillRect(0, 1, start, start + 2, rgb(245, 70, 70));
          }

          const scoreWidth = Math.min(cols, Math.floor(state.score / 110));
          if (scoreWidth > 0) {
            g.fillRect(0, 1, cols - scoreWidth, cols, rgb(90, 175, 255));
          }

          const coinWidth = Math.min(Math.floor(cols / 3), state.collectedCoins * 2);
          if (coinWidth > 0) {
            g.fillRect(1, 2, cols - coinWidth, cols, rgb(255, 220, 90));
          }

          const distanceWidth = Math.min(Math.floor(cols / 2), Math.floor(state.distance / 22));
          if (distanceWidth > 0) {
            g.fillRect(1, 2, 0, distanceWidth, rgb(60, 220, 110));
          }
        }

        function draw() {
          for (let row = 0; row < rows; row += 1) {
            const shade = 5 + Math.floor((row / Math.max(1, rows - 1)) * 18);
            const color = rgb(Math.floor(shade / 2), Math.floor(shade / 2), shade);
            g.fillRect(row, row + 1, 0, cols, color);
          }

          const boundaries = [Math.floor(cols / 3), Math.floor((cols * 2) / 3)];
          for (const b of boundaries) {
            for (let row = 2; row < rows; row += 1) {
              if (((row + Math.floor(state.frame / 2)) % 6) < 3) {
                g.fillRect(row, row + 1, b - 1, b + 1, rgb(22, 26, 36));
              }
            }
          }

          for (let i = 0; i < 10; i += 1) {
            const row = (state.frame + i * 4) % rows;
            const col = (i * 9 + state.frame) % cols;
            if (row > 2) g.setPixel(row, col, rgb(18, 20, 30));
          }

          for (const obstacle of state.obstacles) {
            const y = Math.round(obstacle.y);
            if (y < -4 || y >= rows + 3) continue;
            const centerX = state.laneCenters[obstacle.lane];
            const width = clamp(3 + (Math.max(y, 0) / Math.max(1, rows - 1)) * 5, 3, 8);
            g.fillRect(y - 2, y + 2, centerX - width, centerX + width + 1, rgb(230, 80, 70));
          }

          for (const coin of state.coins) {
            const y = Math.round(coin.y);
            if (y < 0 || y >= rows) continue;
            const x = state.laneCenters[coin.lane];
            g.fillRect(y, y + 1, x - 1, x + 2, rgb(255, 220, 80));
            g.fillRect(y - 1, y, x, x + 1, rgb(255, 220, 80));
            g.fillRect(y + 1, y + 2, x, x + 1, rgb(255, 220, 80));
          }

          drawRunner();
          drawHud();

          if (state.crashFlash > 0 && state.crashFlash % 2 === 0) {
            g.overlay("#ffffff", 0.2);
          }
          if (state.gameOverPause > 0 && state.gameOverPause % 10 < 5) {
            g.overlay("#8f0606", 0.24);
          }
        }

        resetRound();
        return {
          update(dt) {
            accumulator += dt;
            while (accumulator >= stepDt) {
              logicStep();
              accumulator -= stepDt;
            }
            draw();
          },
        };
      }

      function createBreakerSim(canvas) {
        const cols = 36;
        const rows = 24;
        const g = makeGrid(canvas, cols, rows);
        const stepDt = 0.038;
        let accumulator = 0;

        const DIGIT_PATTERNS = {
          "0": ["111", "101", "101", "101", "111"],
          "1": ["010", "110", "010", "010", "111"],
          "2": ["111", "001", "111", "100", "111"],
          "3": ["111", "001", "111", "001", "111"],
          "4": ["101", "101", "111", "001", "001"],
          "5": ["111", "100", "111", "001", "111"],
          "6": ["111", "100", "111", "101", "111"],
          "7": ["111", "001", "001", "001", "001"],
          "8": ["111", "101", "111", "101", "111"],
          "9": ["111", "101", "111", "001", "111"],
        };

        const state = {
          rows,
          cols,
          paddleWidth: Math.max(7, Math.floor(cols / 9)),
          paddleRow: rows - 3,
          paddleX: 0,
          ballX: 0,
          ballY: 0,
          ballVx: 0,
          ballVy: 0,
          bricks: [],
          score: 0,
          lives: 3,
          level: 1,
          frame: 0,
          gameOverPause: 0,
          framesWithoutBrickHit: 0,
        };

        function resetBall() {
          state.ballX = state.paddleX + state.paddleWidth / 2;
          state.ballY = state.paddleRow - 1.2;
          const speed = 1.05 + state.level * 0.06;
          const vxSeed = pick([-0.85, -0.7, 0.7, 0.85]);
          state.ballVx = vxSeed;
          state.ballVy = -Math.max(0.75, speed - Math.abs(vxSeed) * 0.35);
        }

        function createBricks(level) {
          const rowCount = Math.min(7, 4 + Math.max(0, level - 1));
          const brickW = Math.max(4, Math.floor(cols / 13));
          const gap = 1;
          const colCount = Math.max(6, Math.floor(cols / (brickW + gap)));
          const totalW = colCount * brickW + (colCount - 1) * gap;
          const xStart = Math.max(0, Math.floor((cols - totalW) / 2));
          const palette = [
            [230, 90, 35],
            [220, 160, 35],
            [80, 220, 90],
            [45, 160, 240],
            [155, 120, 245],
            [245, 120, 210],
          ];

          state.bricks = [];
          for (let row = 0; row < rowCount; row += 1) {
            const y = 2 + row * 2;
            if (y >= state.paddleRow - 3) break;
            const color = palette[row % palette.length];
            for (let i = 0; i < colCount; i += 1) {
              const x0 = xStart + i * (brickW + gap);
              const x1 = Math.min(cols - 1, x0 + brickW - 1);
              state.bricks.push({ x0, x1, y, color });
            }
          }
        }

        function startLevel(level) {
          state.level = level;
          state.framesWithoutBrickHit = 0;
          createBricks(level);
          state.paddleX = (cols - state.paddleWidth) / 2;
          resetBall();
        }

        function resetGame() {
          state.score = 0;
          state.lives = 3;
          state.level = 1;
          state.frame = 0;
          state.gameOverPause = 0;
          state.framesWithoutBrickHit = 0;
          startLevel(1);
        }

        function autoMovePaddle() {
          const targetLeft = clamp(
            state.ballX - state.paddleWidth / 2,
            0,
            cols - state.paddleWidth
          );
          state.paddleX += clamp(targetLeft - state.paddleX, -2.2, 2.2);
          state.paddleX = clamp(state.paddleX, 0, cols - state.paddleWidth);
        }

        function updateBall() {
          state.framesWithoutBrickHit += 1;
          const prevX = state.ballX;
          const prevY = state.ballY;
          let nextX = state.ballX + state.ballVx;
          let nextY = state.ballY + state.ballVy;

          if (nextX <= 0) {
            nextX = 0;
            state.ballVx = Math.abs(state.ballVx);
          } else if (nextX >= cols - 1) {
            nextX = cols - 1;
            state.ballVx = -Math.abs(state.ballVx);
          }

          if (nextY <= 2) {
            nextY = 2;
            state.ballVy = Math.abs(state.ballVy);
          }

          const paddleY = state.paddleRow - 1.2;
          if (state.ballVy > 0 && prevY < paddleY && paddleY <= nextY) {
            if ((state.paddleX - 0.4) <= nextX && nextX <= (state.paddleX + state.paddleWidth + 0.4)) {
              let hitOffset = (nextX - (state.paddleX + state.paddleWidth / 2)) /
                Math.max(1, state.paddleWidth / 2);
              hitOffset = clamp(hitOffset, -1, 1);

              const baseSpeed = Math.min(2.4, 1.05 + state.level * 0.09 + state.score / 1400);
              state.ballVx = clamp(hitOffset * 1.45, -1.35, 1.35);
              if (Math.abs(state.ballVx) < 0.35) {
                let dirHint = Math.sign(hitOffset);
                if (dirHint === 0) {
                  dirHint = Math.sign(prevX - (state.paddleX + state.paddleWidth / 2));
                }
                if (dirHint === 0) {
                  dirHint = pick([-1, 1]);
                }
                state.ballVx = 0.35 * dirHint;
              }
              state.ballVy = -Math.max(0.78, baseSpeed - Math.abs(state.ballVx) * 0.3);
              state.ballVx = clamp(state.ballVx, -1.45, 1.45);
              state.ballVy = clamp(state.ballVy, -1.85, 1.85);
              nextY = state.paddleRow - 1.25;
            }
          }

          let hitIdx = -1;
          let hitAxis = "y";
          for (let idx = 0; idx < state.bricks.length; idx += 1) {
            const brick = state.bricks[idx];
            const insideNext =
              brick.x0 <= nextX && nextX <= brick.x1 &&
              brick.y <= nextY && nextY <= brick.y + 1;
            const crossedX = Math.min(prevX, nextX) <= brick.x1 && Math.max(prevX, nextX) >= brick.x0;
            const crossedY = Math.min(prevY, nextY) <= (brick.y + 1) && Math.max(prevY, nextY) >= brick.y;
            if (!insideNext && !(crossedX && crossedY)) continue;

            const enterFromTop = prevY <= brick.y && brick.y < nextY;
            const enterFromBottom = prevY >= (brick.y + 1) && (brick.y + 1) > nextY;
            const enterFromLeft = prevX <= brick.x0 && brick.x0 < nextX;
            const enterFromRight = prevX >= brick.x1 && brick.x1 > nextX;

            if (enterFromLeft || enterFromRight) {
              hitAxis = "x";
            } else if (enterFromTop || enterFromBottom) {
              hitAxis = "y";
            } else {
              const dx = Math.min(Math.abs(nextX - brick.x0), Math.abs(nextX - brick.x1));
              const dy = Math.min(Math.abs(nextY - brick.y), Math.abs(nextY - (brick.y + 1)));
              hitAxis = dx < dy ? "x" : "y";
            }

            hitIdx = idx;
            break;
          }

          if (hitIdx !== -1) {
            state.bricks.splice(hitIdx, 1);
            state.score += 12 + state.level * 2;
            state.framesWithoutBrickHit = 0;
            if (hitAxis === "x") {
              state.ballVx *= -1;
            } else {
              state.ballVy *= -1;
            }
            state.ballVx = clamp(state.ballVx * 1.01, -1.45, 1.45);
            state.ballVy = clamp(state.ballVy * 1.01, -1.85, 1.85);
            nextY = state.ballY + state.ballVy;
          }

          if (state.bricks.length > 0 && state.framesWithoutBrickHit > 220) {
            const speed = clamp(Math.hypot(state.ballVx, state.ballVy), 1.05, 2.2);
            state.ballVx = pick([-1.05, -0.85, 0.85, 1.05]);
            const vySign = state.ballVy < 0 ? -1 : 1;
            state.ballVy = vySign * Math.max(0.78, speed - Math.abs(state.ballVx) * 0.22);
            state.ballVx = clamp(state.ballVx, -1.45, 1.45);
            state.ballVy = clamp(state.ballVy, -1.85, 1.85);
            nextX = clamp(state.ballX + state.ballVx, 0, cols - 1);
            nextY = clamp(state.ballY + state.ballVy, 2, rows - 1);
            state.framesWithoutBrickHit = 0;
          }

          state.ballX = nextX;
          state.ballY = nextY;

          if (state.ballY >= rows - 1) {
            state.lives -= 1;
            if (state.lives > 0) {
              state.framesWithoutBrickHit = 0;
              resetBall();
            }
          }
        }

        function drawNumber(value, topRow, rightCol, color) {
          if (topRow < 0 || topRow + 5 > rows) return;
          let text = String(Math.max(0, Math.floor(value)));
          const digitW = 3;
          const gap = 1;
          let totalW = text.length * digitW + (text.length - 1) * gap;
          let leftCol = rightCol - totalW + 1;
          if (leftCol < 0) {
            const overflow = -leftCol;
            const trimDigits = Math.floor((overflow + digitW + gap - 1) / (digitW + gap));
            text = text.slice(trimDigits);
            totalW = text.length * digitW + (text.length - 1) * gap;
            leftCol = rightCol - totalW + 1;
            if (leftCol < 0) return;
          }

          let cursor = leftCol;
          for (const ch of text) {
            const pattern = DIGIT_PATTERNS[ch];
            if (!pattern) {
              cursor += digitW + gap;
              continue;
            }
            for (let r = 0; r < pattern.length; r += 1) {
              for (let c = 0; c < pattern[r].length; c += 1) {
                if (pattern[r][c] === "1") {
                  g.setPixel(topRow + r, cursor + c, color);
                }
              }
            }
            cursor += digitW + gap;
          }
        }

        function logicStep() {
          if (state.gameOverPause > 0) {
            state.gameOverPause -= 1;
            if (state.gameOverPause === 0) resetGame();
            return;
          }

          state.frame += 1;
          autoMovePaddle();
          updateBall();

          if (state.bricks.length === 0) {
            startLevel(state.level + 1);
          }

          if (state.lives <= 0) {
            state.gameOverPause = 60;
          }
        }

        function draw() {
          g.fillRect(0, rows, 0, cols, rgb(6, 10, 18));
          for (let i = 0; i < 16; i += 1) {
            const row = (state.frame + i * 7) % rows;
            const col = (i * 9 + Math.floor(state.frame / 2)) % cols;
            if (row > 1) g.setPixel(row, col, rgb(16, 24, 38));
          }

          for (const brick of state.bricks) {
            g.fillRect(brick.y, brick.y + 2, brick.x0, brick.x1 + 1, rgb(brick.color[0], brick.color[1], brick.color[2]));
          }

          const paddleStart = Math.round(state.paddleX);
          g.fillRect(state.paddleRow, state.paddleRow + 2, paddleStart, paddleStart + state.paddleWidth, rgb(250, 235, 115));
          g.setPixel(clamp(Math.round(state.ballY), 2, rows - 1), clamp(Math.round(state.ballX), 0, cols - 1), rgb(245, 245, 245));

          for (let i = 0; i < state.lives; i += 1) {
            const start = i * 3;
            g.fillRect(0, 1, start, start + 2, rgb(35, 225, 35));
          }

          const levelWidth = Math.min(Math.floor(cols / 2), state.level * 4);
          if (levelWidth > 0) {
            g.fillRect(1, 2, 0, levelWidth, rgb(80, 140, 250));
          }

          drawNumber(state.score, 0, cols - 1, rgb(245, 245, 245));

          if (state.gameOverPause > 0 && state.gameOverPause % 12 < 6) {
            g.overlay("#4b0000", 0.25);
          }
        }

        resetGame();
        return {
          update(dt) {
            accumulator += dt;
            while (accumulator >= stepDt) {
              logicStep();
              accumulator -= stepDt;
            }
            draw();
          },
        };
      }

      function createLaneSim(canvas) {
        const cols = 36;
        const rows = 24;
        const g = makeGrid(canvas, cols, rows);
        const stepDt = 0.05;
        let accumulator = 0;

        const HEART_PATTERN = [
          [1, 0, 1],
          [1, 1, 1],
          [0, 1, 0],
        ];

        const DIGIT_PATTERNS = {
          "0": ["111", "101", "101", "101", "111"],
          "1": ["010", "110", "010", "010", "111"],
          "2": ["111", "001", "111", "100", "111"],
          "3": ["111", "001", "111", "001", "111"],
          "4": ["101", "101", "111", "001", "001"],
          "5": ["111", "100", "111", "001", "111"],
          "6": ["111", "100", "111", "101", "111"],
          "7": ["111", "001", "001", "001", "001"],
          "8": ["111", "101", "111", "101", "111"],
          "9": ["111", "101", "111", "001", "111"],
        };

        const FASTER_FONT = {
          F: [[1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0]],
          A: [[0, 1, 0], [1, 0, 1], [1, 1, 1], [1, 0, 1], [1, 0, 1]],
          S: [[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1]],
          T: [[1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 0]],
          E: [[1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 0, 0], [1, 1, 1]],
          R: [[1, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 1], [1, 0, 1]],
        };

        const state = {
          rows,
          cols,
          simTime: 0,
          playerRow: Math.max(2, rows - 3),
          laneState: { current: 1, target: 1, targetTime: 0 },
          score: 0,
          successfulScores: 0,
          lives: 3,
          baseTickInterval: 1.8,
          tickInterval: 1.8,
          lastTick: 0,
          frameCount: 0,
          scoreFlash: 0,
          particles: [],
          fasterFlashFrames: 0,
          fasterFlashMax: 36,
          fasterFlashColors: [[255, 255, 0], [0, 255, 255]],
          fasterFlashScore: 0,
          gameOverPause: 0,
          reactionDelay: 0,
          reactionLane: 1,
          moveCadence: 0,
        };

        function laneCols() {
          return [
            Math.max(1, Math.floor(cols / 6)),
            Math.floor(cols / 2),
            Math.min(cols - 2, Math.floor((cols * 5) / 6)),
          ];
        }

        function planReaction() {
          const missChance = state.lives <= 1 ? 0.08 : 0.22;
          const miss = Math.random() < missChance;
          if (miss) {
            const options = [0, 1, 2].filter((lane) => lane !== state.laneState.target);
            state.reactionLane = pick(options);
          } else {
            state.reactionLane = state.laneState.target;
          }
          const maxDelay = Math.max(1, Math.floor((state.tickInterval / stepDt) * 0.45));
          state.reactionDelay = randInt(1, maxDelay);
          state.moveCadence = 0;
        }

        function resetRound() {
          state.simTime = 0;
          state.playerRow = Math.max(2, rows - 3);
          state.laneState.current = 1;
          state.laneState.target = randInt(0, 2);
          state.laneState.targetTime = 0;
          state.score = 0;
          state.successfulScores = 0;
          state.lives = 3;
          state.tickInterval = state.baseTickInterval;
          state.lastTick = 0;
          state.frameCount = 0;
          state.scoreFlash = 0;
          state.particles = [];
          state.fasterFlashFrames = 0;
          state.fasterFlashScore = 0;
          state.gameOverPause = 0;
          planReaction();
        }

        function drawLives(lives) {
          const color = rgb(0, 0, 255);
          for (let i = 0; i < lives; i += 1) {
            const startCol = i * 4;
            const startRow = 0;
            for (let r = 0; r < HEART_PATTERN.length; r += 1) {
              for (let c = 0; c < HEART_PATTERN[r].length; c += 1) {
                if (HEART_PATTERN[r][c]) {
                  g.setPixel(startRow + r, startCol + c, color);
                }
              }
            }
          }
        }

        function emitParticles(count, color, speedMin, speedMax, lifeMin, lifeMax) {
          const lanes = laneCols();
          const playerCol = lanes[state.laneState.current];
          for (let i = 0; i < count; i += 1) {
            const angle = Math.random() * Math.PI * 2;
            const speed = speedMin + (Math.random() * (speedMax - speedMin));
            state.particles.push({
              x: playerCol,
              y: state.playerRow,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: randInt(lifeMin, lifeMax),
              maxLife: lifeMax,
              color,
            });
          }
        }

        function updateParticles() {
          const alive = [];
          for (const p of state.particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.life -= 1;
            if (p.life > 0) alive.push(p);
          }
          state.particles = alive;
        }

        function drawParticles() {
          for (const p of state.particles) {
            const alpha = p.life / p.maxLife;
            const color = rgb(
              Math.floor(p.color[0] * alpha),
              Math.floor(p.color[1] * alpha),
              Math.floor(p.color[2] * alpha)
            );
            g.setPixel(Math.round(p.y), Math.round(p.x), color);
          }
        }

        function drawNumber(value, topRow, rightCol, color) {
          if (topRow < 0 || topRow + 5 > rows) return;
          const text = String(Math.max(0, Math.floor(value)));
          const digitW = 3;
          const gap = 1;
          const totalW = text.length * digitW + (text.length - 1) * gap;
          let leftCol = rightCol - totalW + 1;
          if (leftCol < 0) leftCol = 0;
          let cursor = leftCol;
          for (const ch of text) {
            const pattern = DIGIT_PATTERNS[ch];
            if (!pattern) {
              cursor += digitW + gap;
              continue;
            }
            for (let r = 0; r < pattern.length; r += 1) {
              for (let c = 0; c < pattern[r].length; c += 1) {
                if (pattern[r][c] === "1") {
                  g.setPixel(topRow + r, cursor + c, color);
                }
              }
            }
            cursor += digitW + gap;
          }
        }

        function drawTextBlock(text, row, col, color) {
          for (let idx = 0; idx < text.length; idx += 1) {
            const char = text[idx];
            const pattern = FASTER_FONT[char];
            if (!pattern) continue;
            for (let r = 0; r < 5; r += 1) {
              for (let c = 0; c < 3; c += 1) {
                if (pattern[r][c]) {
                  g.setPixel(row + r, col + idx * 4 + c, color);
                }
              }
            }
          }
        }

        function logicStep() {
          if (state.gameOverPause > 0) {
            state.gameOverPause -= 1;
            if (state.gameOverPause === 0) resetRound();
            return;
          }

          state.simTime += stepDt;
          state.frameCount += 1;

          if (state.reactionDelay > 0) {
            state.reactionDelay -= 1;
          } else {
            state.moveCadence = (state.moveCadence + 1) % 3;
            if (state.moveCadence === 0) {
              if (state.laneState.current < state.reactionLane) state.laneState.current += 1;
              if (state.laneState.current > state.reactionLane) state.laneState.current -= 1;
            }
          }

          if (state.fasterFlashFrames > 0) {
            state.fasterFlashFrames -= 1;
            if (state.fasterFlashFrames === 0) {
              state.lastTick = state.simTime;
              state.laneState.targetTime = state.simTime;
            }
          } else if ((state.simTime - state.lastTick) >= state.tickInterval) {
            state.lastTick = state.simTime;

            if (state.laneState.current === state.laneState.target) {
              state.score += 1;
              state.successfulScores += 1;
              state.scoreFlash = 10;
              emitParticles(12, [0, 255, 0], 0.5, 2.0, 26, 30);
              if (state.successfulScores % 3 === 0) {
                state.fasterFlashFrames = state.fasterFlashMax;
                state.fasterFlashScore = state.score;
                state.tickInterval = Math.max(
                  0.5,
                  state.baseTickInterval * (0.90 ** Math.floor(state.successfulScores / 3))
                );
              }
            } else {
              state.lives -= 1;
              emitParticles(16, [0, 0, 255], 0.8, 2.5, 30, 35);
            }

            state.laneState.target = randInt(0, 2);
            state.laneState.targetTime = state.simTime;
            planReaction();
            if (state.lives <= 0) {
              state.gameOverPause = 48;
            }
          }

          if (state.scoreFlash > 0) state.scoreFlash -= 1;
          updateParticles();
        }

        function draw() {
          g.fillRect(0, rows, 0, cols, rgb(8, 10, 25));
          const lanes = laneCols();

          if (state.fasterFlashFrames > 0) {
            for (let i = 0; i < lanes.length; i += 1) {
              const col = lanes[i];
              g.fillRect(0, rows, col, col + 1, rgb(40, 50, 90));
              g.fillRect(0, rows, col + 1, col + 2, rgb(20, 25, 45));
            }
          } else {
            const timeElapsed = state.simTime - state.laneState.targetTime;
            const fillRatio = Math.max(0, 1 - (timeElapsed / state.tickInterval));
            for (let i = 0; i < lanes.length; i += 1) {
              const col = lanes[i];
              if (i === state.laneState.target) {
                const pulse = Math.floor(30 * (0.5 + 0.5 * Math.sin(state.frameCount * 0.1)));
                const targetColor = [50 + pulse, 220 + pulse, 100 + pulse];
                const fillHeight = Math.floor(rows * fillRatio);
                if (fillHeight > 0) {
                  g.fillRect(rows - fillHeight, rows, col, col + 1, rgb(targetColor[0], targetColor[1], targetColor[2]));
                  g.fillRect(rows - fillHeight, rows, col + 1, col + 2, rgb(
                    Math.floor(targetColor[0] / 2),
                    Math.floor(targetColor[1] / 2),
                    Math.floor(targetColor[2] / 2)
                  ));
                }
                if (fillHeight < rows) {
                  g.fillRect(0, rows - fillHeight, col, col + 1, rgb(20, 20, 30));
                  g.fillRect(0, rows - fillHeight, col + 1, col + 2, rgb(10, 10, 15));
                }
              } else {
                g.fillRect(0, rows, col, col + 1, rgb(40, 50, 90));
                g.fillRect(0, rows, col + 1, col + 2, rgb(20, 25, 45));
              }
            }
          }

          const playerCol = lanes[state.laneState.current];
          let playerColor = [255, 220, 80];
          if (state.scoreFlash > 0) {
            const flashIntensity = Math.floor(100 * (state.scoreFlash / 10));
            playerColor = [255, 255, Math.min(255, 80 + Math.floor(flashIntensity / 2))];
          }
          g.fillRect(
            state.playerRow,
            state.playerRow + 2,
            playerCol,
            playerCol + 2,
            rgb(playerColor[0], playerColor[1], playerColor[2])
          );

          drawParticles();

          drawLives(state.lives);

          const scoreColor = state.scoreFlash > 0 ? rgb(150, 200, 255) : rgb(90, 160, 255);
          drawNumber(state.score, 0, cols - 1, scoreColor);

          if (state.fasterFlashFrames > 0) {
            const color = state.fasterFlashColors[Math.floor(state.fasterFlashFrames / 6) % 2];
            const row = Math.floor(rows / 2) - 2;
            const col = Math.floor((cols - (6 * 4) + 1) / 2);
            drawTextBlock("FASTER", row, col, rgb(color[0], color[1], color[2]));
          }

          if (state.gameOverPause > 0 && state.gameOverPause % 10 < 5) {
            g.overlay("#350000", 0.25);
          }
        }

        resetRound();
        return {
          update(dt) {
            accumulator += dt;
            while (accumulator >= stepDt) {
              logicStep();
              accumulator -= stepDt;
            }
            draw();
          },
        };
      }

      function createHoleSim(canvas) {
        const cols = 36;
        const rows = 24;
        const g = makeGrid(canvas, cols, rows);
        const stepDt = 0.02;
        let accumulator = 0;

        const DIGIT_PATTERNS = {
          "0": ["111", "101", "101", "101", "111"],
          "1": ["010", "110", "010", "010", "111"],
          "2": ["111", "001", "111", "100", "111"],
          "3": ["111", "001", "111", "001", "111"],
          "4": ["101", "101", "111", "001", "001"],
          "5": ["111", "100", "111", "001", "111"],
          "6": ["111", "100", "111", "101", "111"],
          "7": ["111", "001", "001", "001", "001"],
          "8": ["111", "101", "111", "101", "111"],
          "9": ["111", "101", "111", "001", "111"],
        };

        const state = {
          playerRow: rows - 2,
          playerCol: Math.floor(cols / 2),
          playerColFloat: cols / 2,
          playerColor: [0, 255, 255],
          holeWidth: Math.max(2, Math.floor(cols / 6)),
          lineRow: 0,
          holeStart: 0,
          lineInterval: 0.08,
          lineElapsed: 0,
          score: 0,
          lineCount: 0,
          colorSchemes: [
            [[255, 100, 100], [255, 150, 150], [255, 200, 200]],
            [[100, 255, 100], [150, 255, 150], [200, 255, 200]],
            [[100, 100, 255], [150, 150, 255], [200, 200, 255]],
            [[255, 255, 100], [255, 255, 150], [255, 255, 200]],
            [[255, 100, 255], [255, 150, 255], [255, 200, 255]],
            [[100, 255, 255], [150, 255, 255], [200, 255, 255]],
            [[255, 150, 100], [255, 200, 150], [255, 255, 200]],
          ],
          particles: [],
          backgroundOffset: 0,
          playerTrail: [],
          gameOverPause: 0,
          explosionFrame: 0,
          crashRow: rows - 2,
          crashCol: Math.floor(cols / 2),
        };

        function resetRound() {
          state.playerRow = rows - 2;
          state.playerCol = Math.floor(cols / 2);
          state.playerColFloat = state.playerCol;
          state.holeWidth = Math.max(2, Math.floor(cols / 6));
          state.lineRow = 0;
          state.holeStart = randInt(0, cols - state.holeWidth);
          state.lineInterval = 0.08;
          state.lineElapsed = 0;
          state.score = 0;
          state.lineCount = 0;
          state.particles = [];
          state.backgroundOffset = 0;
          state.playerTrail = [];
          state.gameOverPause = 0;
          state.explosionFrame = 0;
          state.crashRow = state.playerRow;
          state.crashCol = state.playerCol;
        }

        function addScoreParticles() {
          const colors = [
            [255, 255, 0],
            [255, 165, 0],
            [255, 0, 255],
            [0, 255, 255],
          ];
          for (let i = 0; i < 3; i += 1) {
            state.particles.push({
              row: state.playerRow - 1,
              col: state.playerCol + randInt(-2, 2),
              color: pick(colors),
              lifetime: 15,
              velocityRow: -0.5 + Math.random() * 0.4,
              velocityCol: -0.3 + Math.random() * 0.6,
            });
          }
        }

        function updateParticles() {
          const alive = [];
          for (const particle of state.particles) {
            particle.lifetime -= 1;
            if (particle.lifetime <= 0) continue;
            particle.row += particle.velocityRow;
            particle.col += particle.velocityCol;
            alive.push(particle);
          }
          state.particles = alive;
        }

        function updateAutoPlayer() {
          const holeCenter = state.holeStart + (state.holeWidth / 2) - 0.5;
          const target = clamp(holeCenter + ((Math.random() - 0.5) * 0.35), 0, cols - 1);
          state.playerColFloat = (0.8 * state.playerColFloat) + (0.2 * target);
          state.playerCol = clamp(Math.round(state.playerColFloat), 0, cols - 1);
        }

        function drawScore() {
          const text = String(Math.max(0, state.score));
          const digitW = 3;
          const gap = 1;
          const totalWidth = text.length * digitW + (text.length - 1) * gap;
          let cursor = Math.max(0, Math.floor((cols - totalWidth) / 2));
          const topRow = 0;
          for (const ch of text) {
            const pattern = DIGIT_PATTERNS[ch];
            if (!pattern) {
              cursor += digitW + gap;
              continue;
            }
            for (let r = 0; r < pattern.length; r += 1) {
              for (let c = 0; c < pattern[r].length; c += 1) {
                if (pattern[r][c] === "1") {
                  g.setPixel(topRow + r, cursor + c, rgb(255, 220, 110));
                }
              }
            }
            cursor += digitW + gap;
          }
        }

        function drawBackground() {
          g.fillRect(0, rows, 0, cols, rgb(0, 0, 0));
          for (let r = 0; r < rows; r += 3) {
            for (let c = 0; c < cols; c += 4) {
              const starValue = (r * 7 + c * 13 + state.backgroundOffset) % 255;
              if (starValue < 5) {
                const brightness = Math.min(50, starValue * 10);
                g.setPixel(r, c, rgb(brightness, brightness, brightness));
              }
            }
          }
        }

        function drawLine() {
          if (state.lineRow < 0 || state.lineRow >= rows) return;
          const currentScheme = state.colorSchemes[state.score % state.colorSchemes.length];
          const lineColor = currentScheme[state.score % currentScheme.length];
          for (let c = 0; c < cols; c += 1) {
            if (state.holeStart <= c && c < state.holeStart + state.holeWidth) continue;
            g.setPixel(state.lineRow, c, rgb(lineColor[0], lineColor[1], lineColor[2]));
          }
        }

        function drawPlayerWithTrail() {
          const trailSlice = state.playerTrail.slice(-5);
          for (let i = 0; i < trailSlice.length; i += 1) {
            const [trailRow, trailCol] = trailSlice[i];
            const fade = (i + 1) / 6.0;
            const rr = Math.floor(state.playerColor[0] * fade * 0.5);
            const gg = Math.floor(state.playerColor[1] * fade * 0.5);
            const bb = Math.floor(state.playerColor[2] * fade * 0.5);
            g.setPixel(trailRow, trailCol, rgb(rr, gg, bb));
          }

          g.setPixel(state.playerRow, state.playerCol, rgb(state.playerColor[0], state.playerColor[1], state.playerColor[2]));

          for (let dr = -1; dr <= 1; dr += 1) {
            for (let dc = -1; dc <= 1; dc += 1) {
              if (dr === 0 && dc === 0) continue;
              const glow = 0.3 / (Math.abs(dr) + Math.abs(dc));
              const rr = Math.floor(state.playerColor[0] * glow);
              const gg = Math.floor(state.playerColor[1] * glow);
              const bb = Math.floor(state.playerColor[2] * glow);
              g.setPixel(state.playerRow + dr, state.playerCol + dc, rgb(rr, gg, bb));
            }
          }
        }

        function drawParticles() {
          for (const particle of state.particles) {
            const row = Math.floor(particle.row);
            const col = Math.floor(particle.col);
            const intensity = particle.lifetime / 15.0;
            const rr = Math.floor(particle.color[0] * intensity);
            const gg = Math.floor(particle.color[1] * intensity);
            const bb = Math.floor(particle.color[2] * intensity);
            g.setPixel(row, col, rgb(rr, gg, bb));
          }
        }

        function drawExplosion() {
          if (state.gameOverPause <= 0) return;
          const radius = state.explosionFrame * 0.5;
          if (radius <= 0) return;
          for (let r = 0; r < rows; r += 1) {
            for (let c = 0; c < cols; c += 1) {
              const distance = Math.sqrt(((r - state.crashRow) ** 2) + ((c - state.crashCol) ** 2));
              if (distance > radius || distance <= radius - 1) continue;
              const intensity = Math.max(0, 1.0 - (distance / Math.max(radius, 1)));
              let color;
              if (state.explosionFrame < 20) {
                color = [255, Math.floor(100 * intensity), 0];
              } else if (state.explosionFrame < 40) {
                color = [255, Math.floor(255 * intensity), Math.floor(100 * intensity)];
              } else {
                color = [Math.floor(255 * intensity), Math.floor(100 * intensity), Math.floor(255 * intensity)];
              }
              g.setPixel(r, c, rgb(color[0], color[1], color[2]));
            }
          }
        }

        function logicStep() {
          state.backgroundOffset += 1;

          if (state.gameOverPause > 0) {
            state.gameOverPause -= 1;
            state.explosionFrame += 1;
            if (state.gameOverPause === 0) resetRound();
            return;
          }

          updateAutoPlayer();

          state.lineElapsed += stepDt;
          while (state.lineElapsed >= state.lineInterval) {
            state.lineElapsed -= state.lineInterval;
            state.lineRow += 1;
            state.lineCount += 1;

            if (state.lineRow >= state.playerRow) {
              if (state.holeStart <= state.playerCol && state.playerCol < state.holeStart + state.holeWidth) {
                state.score += 1;
                state.lineInterval = Math.max(0.02, state.lineInterval - 0.005);
                state.lineRow = 0;
                state.holeStart = randInt(0, cols - state.holeWidth);
                addScoreParticles();
              } else {
                state.crashRow = state.playerRow;
                state.crashCol = state.playerCol;
                state.gameOverPause = 60;
                state.explosionFrame = 0;
                break;
              }
            }
          }

          state.playerTrail.push([state.playerRow, state.playerCol]);
          if (state.playerTrail.length > 8) state.playerTrail.shift();
          updateParticles();
        }

        function draw() {
          drawBackground();
          drawParticles();
          drawScore();
          drawLine();
          drawPlayerWithTrail();
          drawExplosion();

          if (state.gameOverPause > 0 && state.gameOverPause % 10 < 5) {
            g.overlay("#6d0606", 0.2);
          }
        }

        resetRound();
        return {
          update(dt) {
            accumulator += dt;
            while (accumulator >= stepDt) {
              logicStep();
              accumulator -= stepDt;
            }
            draw();
          },
        };
      }

      const sims = [
        createRunnerSim(document.getElementById("sim-runner")),
        createBreakerSim(document.getElementById("sim-breaker")),
        createLaneSim(document.getElementById("sim-lane")),
        createHoleSim(document.getElementById("sim-hole")),
      ];

      let last = performance.now();
      function animate(now) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        for (const sim of sims) sim.update(dt);
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>
